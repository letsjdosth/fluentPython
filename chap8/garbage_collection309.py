'''
Garbage Collection:
동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법. 더 이상 사용할 수 없게 된 영역이란, 어떤 변수도 가리키지 않게 된 영역을 의미한다. 
파이썬(CPython)의 경우 언어 자체에 구현되어 있음.(C/C++ 등은 없어서 수동 메모리 반환이 중요)
구체적으로는 '참조 횟수 계산 방식'을 사용. 참조 횟수 계산 방식은 각 객체에서 참조 횟수를 기억하여, 참조 횟수가 0이 되면 해당 객체를 해제하는 방식
장점
-객체가 접근 불가능해지는 즉시 메모리가 해제되므로, 프로그래머가 객체의 해제 시점을 어느 정도 예측할 수 있다.
-객체가 사용된 직후에 메모리를 해제하므로, 메모리 해제 시점에 해당 객체는 캐시에 저장되어 있을 확률이 높다. 따라서 메모리 해제가 빠르게 이루어진다.
단점
-매번 참조할 때 마다 참조값을 검사해야 하므로 많은 수의 단위 객체를 사용하게 되면 그 검사에 대한 부하가 커진다
-두개 이상의 객체가 서로를 가리키고 있을 경우, 참조 횟수가 0이 되지 않게 된다. 이를 순환 참조라고 하며, 메모리 누수의 원인이 된다. 
(CPython은 이 문제를 해결하기 위해 순환 참조를 감지하는 알고리즘을 사용한다. 순환참조 그룹을 만들고, 해당 그룹 바깥에서 참조하는 수를 센다. 0이 되면 해당 그룹의 메모리를 다 해제한다)
(또한 자료구조에서 약한 참조(참조 횟수를 증가시키지 않는 포인터)를 사용하여 이 문제를 해결할 수도 있다.)
-멀티스레드 환경에서는, 스레드간에 공유하는 객체의 참조 횟수 계산을 위해 원자적 명령을 사용하거나 락을 걸어야 한다. 
이 문제를 회피하기 위해 스레드 단위 지역 변수로 참조 횟수를 따로 관리하면서, 스레드의 참조 횟수가 0이 될때만 전역 참조 횟수를 확인하는 방식을 사용할 수 있다. 리눅스 커널에서 이 방식을 사용한다.
-참조 횟수가 0이 될때, 해당 객체가 가리키는 다른 객체들 또한 동시에 0으로 만드는 작업이 일어난다. 이 과정은 경우에 따라 많은 시간이 걸릴 수도 있기 때문에 실시간 시스템에는 적합하지 않을 수 있다.

참조 횟수 계산 방식에 강한참조(strong reference)/약한참조(weak reference)가 있고 보통은 강한참조 방식으로 계산 (파이썬도 강한참조만 카운팅)

참고로 대부분은 참조횟수 계산방식이 아닌 포인터 추적 방식(한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고, 그 밖의 메모리를 해제하는 방식)으로 가비지 콜렉팅을 함.
접근 할 수 있는 메모리인지 검사하는 여러 알고리즘이 개발되어 있음
'''


import weakref
s1={1,2,3}
s2=s1 #<-별명 설정
def bye():
	print('Gone with the wind...')

ender=weakref.finalize(s1,bye) #<-콜백 등록. s1이 가리키는 객체가 삭제될 때 bye를 호출함
print(ender.alive) #True

del s1 
print(ender.alive) #True #<-여전히 s2가 보고있기 때문에 원 객체는 지워지지 않았다 #<-!! del은 해당 객체를 지우지 않는다. 이름을 지운다.

s2='spam' #<-s2를 다른 객체에 바인딩한다.
#Gone with the wind... #<-가 출력된다. 더이상 참조하는 이름이 없기 때문에 즉시 지워진다 (weakref.finalize는 여전히 해당 객체를 참조하지만, 이는 '약한 참조'이기 때문에 참조횟수에 계산되지 않는다)
print(ender.alive) #False
